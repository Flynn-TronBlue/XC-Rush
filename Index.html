<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>XC Rush — Endless Follow Cam</title>
<style>
  :root{ --bg:#0e1218; --text:#eef2f8; --grass1:#82d065; --grass2:#73c65a; --track:#e9c58e; --panel:#161b22; --muted:#aab4c0; --accent:#5aa0ff; --coin:#ffd740; }
  html,body{margin:0;padding:0;height:100%;background:var(--bg);color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    -webkit-user-select:none;user-select:none;touch-action:none;}
  #wrap{position:fixed; inset:0; display:flex; align-items:center; justify-content:center;}
  canvas{background:linear-gradient(#8ec9ff 0%, #bfe4ff 45%, #9bd67a 46%, #85cd6e 100%); image-rendering: pixelated; outline:none;}
  #hud{position:absolute; top:env(safe-area-inset-top, 8px); left:0; right:0; display:flex; justify-content:space-between; padding:8px 12px; pointer-events:none; text-shadow:0 2px 0 #0007;}
  #left{display:flex; gap:10px;}
  #score{font-weight:900; font-size:18px; background:#0009; padding:6px 10px; border-radius:10px;}
  #coins{font-weight:700; font-size:14px; background:#0009; padding:6px 10px; border-radius:10px;}
  #user{font-size:14px; opacity:.95; background:#0009; padding:6px 10px; border-radius:10px;}
  #buttons{position:absolute; bottom:calc(env(safe-area-inset-bottom,8px) + 140px); left:0; right:0; display:flex; justify-content:center; gap:10px;}
  .btn{pointer-events:auto; background:var(--panel); border:1px solid #ffffff33; color:#fff; padding:8px 12px; border-radius:999px; font-size:13px; box-shadow:0 6px 14px #0008;}
  #overlay, #shop, #nameAsk{position:absolute; inset:0; display:none; align-items:center; justify-content:center; flex-direction:column; background:linear-gradient(180deg,#0008,#000c);}
  .show{display:flex;}
  #overlay h1{margin:0 0 6px;}
  #overlay p{margin:0 0 10px; opacity:.95; text-align:center;}
  #playBtn{margin-top:6px; background:linear-gradient(180deg,#66b4ff,#5aa0ff); color:white; border:none; border-radius:10px; padding:12px 18px; font-weight:800; box-shadow:0 6px 14px #0008;}
  #shopPanel, #namePanel{background:var(--panel); border:1px solid #ffffff26; border-radius:14px; padding:14px; width:min(92vw,520px); color:var(--text);}
  .grid{display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:10px;}
  .card{background:#0f131a; border:1px solid #ffffff1a; border-radius:10px; padding:10px; display:flex; flex-direction:column; align-items:center; gap:6px;}
  .owned{font-size:12px; color:#19d28f; font-weight:700;}
  .price{font-size:12px; color:var(--coin); font-weight:700;}
  input[type=text]{width:100%; padding:10px 12px; font-size:16px; border-radius:10px; border:1px solid #ffffff2a; background:#0f131a; color:var(--text);}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="540" height="900"></canvas>

  <div id="hud">
    <div id="left">
      <div id="score">0</div>
      <div id="coins">Coins: 0</div>
    </div>
    <div id="user">@runner</div>
  </div>

  <div id="buttons">
    <button class="btn" id="shopBtn">Shop</button>
    <button class="btn" id="nameBtn">Name</button>
  </div>

  <div id="overlay" class="show">
    <h1>XC Rush</h1>
    <p>Swipe to move • Tap = hop forward</p>
    <p>Score +1 for every move. Collect coins; buy skins.</p>
    <button id="playBtn">Tap to Run</button>
  </div>

  <div id="shop">
    <div id="shopPanel">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
        <strong>Skins Shop</strong>
        <span id="shopCoins">Coins: 0</span>
      </div>
      <div class="grid" id="skinsGrid"></div>
      <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:10px;">
        <button class="btn" id="closeShop">Close</button>
        <button class="btn" id="freeCoins">+20 Coins</button>
        <button class="btn" id="reset">Reset Progress</button>
      </div>
    </div>
  </div>

  <div id="nameAsk">
    <div id="namePanel">
      <h3 style="margin-top:0;">Choose a Username</h3>
      <p style="margin:6px 0 10px; opacity:.9;">Shows in the HUD (local only).</p>
      <input type="text" id="nameInput" placeholder="e.g., XC_Sully" maxlength="16">
      <div style="display:flex; justify-content:flex-end; margin-top:10px;">
        <button class="btn" id="saveName">Save</button>
      </div>
    </div>
  </div>
</div>

<script>
// ====== Storage ======
const S = { coins:'xcr_pf_coins', skins:'xcr_pf_skins', eq:'xcr_pf_equipped', user:'xcr_pf_user', best:'xcr_pf_best' };
let coins = Number(localStorage.getItem(S.coins) || 0);
let skinsOwned = JSON.parse(localStorage.getItem(S.skins) || '["default"]');
let equipped = localStorage.getItem(S.eq) || 'default';
let username = localStorage.getItem(S.user) || '';
let best = Number(localStorage.getItem(S.best) || 0);
function saveState(){
  localStorage.setItem(S.coins, String(coins));
  localStorage.setItem(S.skins, JSON.stringify(skinsOwned));
  localStorage.setItem(S.eq, equipped);
  if (username) localStorage.setItem(S.user, username);
  document.getElementById('coins').textContent = 'Coins: ' + coins;
  document.getElementById('shopCoins').textContent = 'Coins: ' + coins;
  document.getElementById('user').textContent = username ? '@'+username : '@runner';
}
saveState();

// ====== UI refs ======
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', {alpha:false});
ctx.imageSmoothingEnabled = false;
const overlay = document.getElementById('overlay');
const playBtn = document.getElementById('playBtn');
const shop = document.getElementById('shop');
const skinsGrid = document.getElementById('skinsGrid');
const closeShop = document.getElementById('closeShop');
const freeCoins = document.getElementById('freeCoins');
const resetBtn = document.getElementById('reset');
const nameAsk = document.getElementById('nameAsk');
const nameBtn = document.getElementById('nameBtn');
const nameInput = document.getElementById('nameInput');
const saveName = document.getElementById('saveName');
const shopBtn = document.getElementById('shopBtn');
const scoreEl = document.getElementById('score');

// ====== Game constants ======
const TILE = 48, COLS = 9, ROWS = 18;
const W = COLS*TILE, H = ROWS*TILE;
canvas.width = W; canvas.height = H;

// ====== RNG ======
let seed = Math.floor(Math.random()*1e9);
function rand(){ seed = (seed*1664525 + 1013904223)>>>0; return (seed>>>8)/0xFFFFFF; }
function r(min,max){ return min + rand()*(max-min); }
function ri(min,max){ return Math.floor(r(min,max+1)); }
function chance(p){ return rand() < p; }

// ====== Skins ======
const SKINS = [
  { id:'default', name:'Classic', price:0, colors:{body:'#ffffff', trim:'#5aa0ff', shoes:'#1e1e1e'} },
  { id:'forest',  name:'Forest Team', price:80, colors:{body:'#eaf4e6', trim:'#2ecc71', shoes:'#1e1e1e'} },
  { id:'flame',   name:'Flame Team',  price:120, colors:{body:'#fff1e6', trim:'#ff8a00', shoes:'#1e1e1e'} },
  { id:'royal',   name:'Royal Team',  price:150, colors:{body:'#eef2ff', trim:'#5a90ff', shoes:'#1e1e1e'} },
  { id:'night',   name:'Night Ops',   price:240, colors:{body:'#dfe6f3', trim:'#222831', shoes:'#111'} },
  { id:'gold',    name:'Gold Elite',  price:600, colors:{body:'#fff9d6', trim:'#ffd740', shoes:'#1e1e1e'} }
];
function skinById(id){ return SKINS.find(s=>s.id===id) || SKINS[0]; }

function renderShop(){
  skinsGrid.innerHTML = '';
  SKINS.forEach(s => {
    const owned = skinsOwned.includes(s.id);
    const card = document.createElement('div'); card.className='card';
    const prev = document.createElement('canvas'); prev.width=96; prev.height=96;
    const pctx = prev.getContext('2d'); pctx.imageSmoothingEnabled=false;
    drawRunnerPreview(pctx, s.colors);
    const name = document.createElement('div'); name.textContent = s.name;
    const price = document.createElement('div'); price.className = owned ? 'owned' : 'price';
    price.textContent = owned ? 'Owned' : (s.price+' coins');
    const btn = document.createElement('button'); btn.className='btn';
    btn.textContent = owned ? (equipped===s.id?'Equipped':'Equip') : 'Buy';
    btn.onclick = () => {
      if (owned){ equipped = s.id; saveState(); renderShop(); }
      else {
        if (coins >= s.price){ coins -= s.price; skinsOwned.push(s.id); equipped=s.id; saveState(); renderShop(); }
        else alert('Not enough coins.');
      }
    };
    card.append(prev, name, price, btn);
    skinsGrid.appendChild(card);
  });
}

closeShop.onclick = ()=>shop.classList.remove('show');
shopBtn.onclick = ()=>{ renderShop(); shop.classList.add('show'); };
nameBtn.onclick = ()=>{ nameInput.value = username||''; nameAsk.classList.add('show'); };
saveName.onclick = ()=>{ const v=(nameInput.value||'').trim().replace(/[^a-zA-Z0-9_]/g,''); if(!v){ alert('Use letters, numbers, underscore.'); return;} username=v; saveState(); nameAsk.classList.remove('show'); };
freeCoins.onclick = ()=>{ coins += 20; saveState(); };
resetBtn.onclick = ()=>{ if (confirm('Reset coins, skins, best, and name?')){ coins=0; skinsOwned=['default']; equipped='default'; username=''; localStorage.removeItem(S.user); saveState(); renderShop(); } };

if (!username) setTimeout(()=> nameAsk.classList.add('show'), 700);

// ====== World ======
let lanes = []; // each lane: { type, ents:[{kind,x,y,vx?,taken?}] , y }
let cameraY = 0;
let player = null;
let alive = false;
let score = 0;
let moveCount = 0;
let particles = [];

function laneType(){ const pool=['trail','trail','trail','mud','bridge','trail']; return pool[ri(0,pool.length-1)]; }

function makeLane(type, yIndex){
  const lane = { type, ents:[], y:yIndex, decor:[] };
  const obsP = type==='mud' ? 0.35 : 0.25;
  for (let x=0; x<COLS; x++){
    if (chance(obsP)){
      const kind = chance(0.6) ? 'tree' : 'rock';
      lane.ents.push({ kind, x, y:yIndex, id: 'o_'+yIndex+'_'+x });
    } else if (chance(0.14)){
      lane.ents.push({ kind:'runner', x:x, y:yIndex, vx: chance(0.5)? -0.7 : 0.7, id:'r_'+yIndex+'_'+x });
    } else if (chance(0.15)){
      lane.ents.push({ kind:'coin', x:x, y:yIndex, taken:false, id:'c_'+yIndex+'_'+x });
    }
  }
  return lane;
}

function appendLane(){ lanes.push(makeLane(laneType(), lanes.length)); }
function prependLane(){
  // Create a new lane at the "top" with y=0, then shift all existing lanes down by +1
  const newLane = makeLane(laneType(), 0);
  lanes.forEach(l => { l.y += 1; l.ents.forEach(e=>e.y+=1); });
  lanes.unshift(newLane);
  // Because we incremented all y (including player's), player stays visually where they are but we have fresh space above.
  player.y += 1;
}

function initWorld(){
  lanes = [];
  for (let i=0;i<40;i++) appendLane();
}

function reset(){
  initWorld();
  player = { x: Math.floor(COLS/2), y: 12, frame:0, anim:0 };
  cameraY = player.y*TILE - TILE*9;
  alive = true; score = 0; moveCount = 0;
  scoreEl.textContent = '0';
  overlay.classList.remove('show');
}

function ensureWorld(){
  // If player is near the top of the screen, prepend a lane to extend the world upward.
  const SAFE_TOP = 5;
  if (player.y <= SAFE_TOP){
    prependLane();
  }
  // Maintain a buffer at the bottom as well
  while (lanes.length < player.y + 60) appendLane();
  // Prune far behind to avoid unbounded growth
  if (lanes.length > 180){
    // Remove some from the bottom (highest y), but keep indices consistent by just cutting array end
    lanes.length = 180;
  }
}

function hop(dx,dy){
  if (!alive) return;
  // If moving up and near the top, grow world first so target tile exists
  if (dy < 0 && player.y <= 5) prependLane();
  const nx = clamp(player.x + dx, 0, COLS-1);
  const ny = clamp(player.y + dy, 0, lanes.length-1);
  const target = lanes[ny];
  const blocked = target.ents.some(e => (e.kind==='tree'||e.kind==='rock'||e.kind==='runner') && Math.round(e.x)===nx && e.y===ny);
  if (!blocked){
    player.x = nx; player.y = ny;
    moveCount += 1; score = moveCount;
    scoreEl.textContent = String(score);
    ensureWorld();
  }
  // camera follows
  const targetCam = player.y*TILE - TILE*9;
  cameraY = Math.min(cameraY, targetCam);
}

function clamp(v,lo,hi){ return Math.max(lo, Math.min(hi, v)); }

// ====== Input ======
let sx=0, sy=0;
canvas.addEventListener('touchstart', e => { const t=e.changedTouches[0]; sx=t.clientX; sy=t.clientY; }, {passive:true});
canvas.addEventListener('touchend', e => {
  const t=e.changedTouches[0]; const dx=t.clientX-sx, dy=t.clientY-sy; const adx=Math.abs(dx), ady=Math.abs(dy);
  if (!alive){ start(); return; }
  if (adx<18 && ady<18){ hop(0,-1); return; }
  if (adx>ady) hop(Math.sign(dx),0); else hop(0,Math.sign(dy));
}, {passive:true});

// ====== Loop ======
let last=0;
function loop(ts){
  if (!last) last=ts;
  const dt=Math.min(0.033, (ts-last)/1000); last=ts;
  if (alive) update(dt);
  draw();
  requestAnimationFrame(loop);
}

function update(dt){
  // move runner obstacles
  for (const lane of lanes){
    for (const e of lane.ents){
      if (e.kind==='runner'){
        e.x += e.vx*dt;
        if (e.x < -0.45) e.x = COLS-0.55;
        if (e.x > COLS-0.55) e.x = -0.45;
      }
    }
  }
  // collision at player tile
  const lane = lanes[player.y];
  for (const e of lane.ents){
    if (Math.round(e.x)===player.x && e.y===player.y){
      if (e.kind==='coin' && !e.taken){ e.taken=true; coins += 1; saveState(); }
      if (e.kind==='tree' || e.kind==='rock' || e.kind==='runner'){
        alive = false;
        overlay.classList.add('show');
        overlay.innerHTML = `
          <h1>Race Over</h1>
          <p>Score: <strong>${score}</strong> &nbsp;•&nbsp; Coins: <strong>${coins}</strong></p>
          <button id="playBtn">Run Again</button>`;
        document.getElementById('playBtn').onclick = ()=>{ overlay.classList.remove('show'); reset(); };
        return;
      }
    }
  }
}

// ====== Drawing ======
function draw(){
  ctx.clearRect(0,0,W,H);

  // clouds
  drawClouds();

  // lanes
  const start = Math.max(0, Math.floor(cameraY / TILE) - 1);
  const end = Math.min(lanes.length-1, start + ROWS + 4);
  for (let y=start; y<=end; y++){
    const lane = lanes[y];
    const sy = y*TILE - cameraY;
    // grass stripes
    ctx.fillStyle = (y%2===0) ? css('--grass1') : css('--grass2');
    ctx.fillRect(0, sy, W, TILE);
    // track lines
    ctx.fillStyle = css('--track');
    ctx.fillRect(TILE*1.0, sy+TILE*0.68, W - TILE*2.0, 3);
    ctx.fillRect(TILE*1.0, sy+TILE*0.32, W - TILE*2.0, 3);
    // entities
    for (const e of lane.ents){
      const sx = Math.round(e.x*TILE);
      if (e.kind==='tree') drawTree(sx, Math.round(sy - TILE*0.2));
      if (e.kind==='rock') drawRock(sx, Math.round(sy + TILE*0.2));
      if (e.kind==='runner') drawOtherRunner(sx, Math.round(sy));
      if (e.kind==='coin' && !e.taken) drawCoin(sx, Math.round(sy));
    }
  }

  // player
  if (player){
    const px = Math.round(player.x*TILE);
    const py = Math.round(player.y*TILE - cameraY);
    drawRunner(px, py, skinById(equipped).colors);
  }
}

// ====== Simple pixel sprites ======
function drawRunner(x,y, colors){
  const cx = x + TILE/2, cy = y + TILE/2;
  const phase = (Date.now()*0.006) % 2; // 0..2 for simple limb swing
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.28)';
  ctx.fillRect(x+8, y+TILE*0.86, TILE-16, 5);

  // Head (small circle)
  ctx.fillStyle = '#ffe0c9';
  ctx.beginPath(); ctx.arc(cx, y+12, 6, 0, Math.PI*2); ctx.fill();

  // Torso (thin rectangle)
  ctx.fillStyle = colors.body;
  ctx.fillRect(cx-5, y+18, 10, 16);

  // Trim/bib
  ctx.fillStyle = colors.trim;
  ctx.fillRect(cx-5, y+25, 10, 3);

  // Shorts
  ctx.fillStyle = colors.shoes;
  ctx.fillRect(cx-6, y+34, 12, 4);

  // Arms (thin angled)
  ctx.fillStyle = colors.body;
  const armSwing = phase<1 ? phase : 2-phase; // 0..1..0
  const a = (armSwing-0.5)*14; // -7..+7 deg approximate
  // left arm
  ctx.save(); ctx.translate(cx-6, y+24); ctx.rotate(a*Math.PI/180); ctx.fillRect(-1,0,2,12); ctx.restore();
  // right arm
  ctx.save(); ctx.translate(cx+6, y+24); ctx.rotate(-a*Math.PI/180); ctx.fillRect(-1,0,2,12); ctx.restore();

  // Legs (alternating stride)
  const leg = (phase<1 ? phase : 2-phase); // 0..1..0
  const la = (leg-0.5)*18;
  // left leg
  ctx.save(); ctx.translate(cx-3, y+36); ctx.rotate(la*Math.PI/180); ctx.fillRect(-1,0,2,12); ctx.restore();
  // right leg
  ctx.save(); ctx.translate(cx+3, y+36); ctx.rotate(-la*Math.PI/180); ctx.fillRect(-1,0,2,12); ctx.restore();

  // Shoes
  ctx.fillStyle = colors.shoes;
  ctx.fillRect(cx-5, y+44, 4, 3);
  ctx.fillRect(cx+1, y+44, 4, 3);
}
function drawOtherRunner(x,y){
  const cx = x + TILE/2;
  const phase = (Date.now()*0.006) % 2;
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.28)';
  ctx.fillRect(x+8, y+TILE*0.86, TILE-16, 5);

  // Head
  ctx.fillStyle = '#f2d6c2';
  ctx.beginPath(); ctx.arc(cx, y+12, 6, 0, Math.PI*2); ctx.fill();

  // Torso
  ctx.fillStyle = '#e7ecff'; // light kit
  ctx.fillRect(cx-5, y+18, 10, 16);

  // Trim
  ctx.fillStyle = '#ff6b6b';
  ctx.fillRect(cx-5, y+25, 10, 3);

  // Shorts
  ctx.fillStyle = '#1e1e1e';
  ctx.fillRect(cx-6, y+34, 12, 4);

  // Arms & legs
  ctx.fillStyle = '#e7ecff';
  const armSwing = phase<1 ? phase : 2-phase;
  const a = (armSwing-0.5)*14;
  ctx.save(); ctx.translate(cx-6, y+24); ctx.rotate(a*Math.PI/180); ctx.fillRect(-1,0,2,12); ctx.restore();
  ctx.save(); ctx.translate(cx+6, y+24); ctx.rotate(-a*Math.PI/180); ctx.fillRect(-1,0,2,12); ctx.restore();
  const leg = (phase<1 ? phase : 2-phase);
  const la = (leg-0.5)*18;
  ctx.save(); ctx.translate(cx-3, y+36); ctx.rotate(la*Math.PI/180); ctx.fillRect(-1,0,2,12); ctx.restore();
  ctx.save(); ctx.translate(cx+3, y+36); ctx.rotate(-la*Math.PI/180); ctx.fillRect(-1,0,2,12); ctx.restore();

  // Shoes
  ctx.fillStyle = '#1e1e1e';
  ctx.fillRect(cx-5, y+44, 4, 3);
  ctx.fillRect(cx+1, y+44, 4, 3);
}
function drawTree(x,y){
  ctx.fillStyle = '#2f6b2f'; ctx.fillRect(x+8, y, TILE-16, TILE);
  ctx.fillStyle = '#3b2f2f'; ctx.fillRect(x+TILE/2-4, y+TILE-10, 8, 10);
}
function drawRock(x,y){ ctx.fillStyle = '#8a96a6'; ctx.fillRect(x+12, y+8, TILE-24, TILE-24); }
function drawCoin(x,y){ ctx.fillStyle = css('--coin'); ctx.fillRect(x+16, y+16, TILE-32, TILE-32); }

// clouds
let clouds = []; for (let i=0;i<8;i++) clouds.push({x:r(-50,W+50), y:r(-350,-60), s:r(0.3,1.1)});
function drawClouds(){
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  for (const c of clouds){
    const y = c.y - cameraY*0.18;
    const x = c.x + Math.sin((Date.now()/10000 + c.y)*0.5)*20*c.s;
    for (let i=0;i<3;i++){ ctx.beginPath(); ctx.arc(x + i*18*c.s, y, 12*c.s*(0.7+i*0.2), 0, Math.PI*2); ctx.fill(); }
  }
}

// ====== Helpers ======
function css(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
function fit(){
  const dpr = Math.max(1, Math.min(3, Math.floor(window.devicePixelRatio||1)));
  const vw = window.innerWidth;
  const scale = Math.floor((vw / W) * dpr);
  const cssW = W * (scale/dpr);
  const cssH = H * (scale/dpr);
  canvas.style.width = cssW+'px';
  canvas.style.height = cssH+'px';
}
window.addEventListener('resize', fit);
fit();

function drawRunnerPreview(pctx, colors){
  pctx.fillStyle = '#0f131a'; pctx.fillRect(0,0,96,96);
  // simple preview block
  pctx.fillStyle = colors.body; pctx.fillRect(24,18,48,32);
  pctx.fillStyle = colors.trim; pctx.fillRect(24,36,48,6);
  pctx.fillStyle = colors.shoes; pctx.fillRect(28,56,40,8);
}

// ====== Start ======
function start(){ overlay.classList.remove('show'); reset(); }
playBtn.addEventListener('click', start, {once:true});
overlay.addEventListener('touchend', ()=>{ if (!alive) start(); }, {passive:true});
setTimeout(()=>{ if (!alive) start(); }, 800);
requestAnimationFrame(loop);
</script>
</body>
</html>
